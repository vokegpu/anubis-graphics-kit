#version 450 core

layout (local_size_x = 1, local_size_y = 1, local_size_z = 1) in;
layout (r8ui, binding = 0) uniform uimage2D OutTexture;

uniform int Size;
uniform int VecSize;

float Rand(vec2 co) {
    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);
}

uint InverseInterpolate(uint currentIndex) {
    uint prod = currentIndex - 1 / VecSize;
    return prod;
}

void main() {
    uint currentIndex = gl_GlobalInvocationID.x;
    uint inverseI = InverseInterpolate(currentIndex);
    uint delimit = currentIndex / VecSize;

    if (inverseI < delimit) {
        ivec2 r_pix = ivec2(currentIndex + 0, gl_GlobalInvocationID.y);
        ivec2 g_pix = ivec2(currentIndex + 1, gl_GlobalInvocationID.y);
        ivec2 b_pix = ivec2(currentIndex + 2, gl_GlobalInvocationID.y);
        ivec2 a_pix = ivec2(currentIndex + 3, gl_GlobalInvocationID.y);

        uint r = imageLoad(OutTexture, r_pix).x;
        uint g = imageLoad(OutTexture, g_pix).x;
        uint b = imageLoad(OutTexture, b_pix).x;
        uint a = imageLoad(OutTexture, a_pix).x;

        float rr = 255 * Rand(vec2(Rand(vec2(r, g)), g));
        float gg = 255 * Rand(vec2(b, Rand(vec2(r, b))));
        float bb = 255 * Rand(vec2(a, b));
        float aa = 255 * Rand(vec2(r, g));

        float greyscale = rr + gg + bb / 3;
        uint greyscalei = uint(greyscale);
    }

    imageStore(OutTexture, ivec2(gl_GlobalInvocationID).xy, ivec4(currentIndex, 0, 0, 0));
}