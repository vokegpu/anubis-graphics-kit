#version 450

layout (local_size_x = 1, local_size_y = 1) in;
layout (rgba32f, binding = 0) uniform writeonly image2D uTextureHeightmap;
layout (rgba16f, binding = 1) uniform image2D uVegetationMap;

#define PI 3.1415926535897932384626433832795

uniform float uFrequency;
uniform float uAmplitude;
uniform float uPersistence;
uniform float uLacunarity;
uniform int uOctaves;
uniform vec2 uGlobalUV;
uniform vec3 uChunkScale;

uniform struct {
    vec3 uGlobalUV;
    vec4 uSeedf;
    int uSeedi;
} uChunkMetadata[4];

uniform bool uCheckNearest;

float rand(vec2 co) {
    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);
}

vec4 hash4(vec4 n) {
    return fract(sin(n) * 1399763.5453123);
}

vec3 hash3(vec3 n) {
    return fract(sin(n) * 1399763.5453123);
}

vec3 hpos(vec3 n) {
    return hash3(vec3(dot(n, vec3(157.0, 113.0, 271.0)), dot(n, vec3(311.0, 337.0, 179.0)), dot(n, vec3(271.0, 557.0, 431.0))));
}

vec4 mod289(vec4 x) {
    return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec4 permute(vec4 x) {
    return mod(((x * 34.0) + 1.0) * x, 289.0);
}

vec4 taylorInvSqrt(vec4 r) {
    return 1.79284291400159 - 0.85373472095314 * r;
}

vec2 fade(vec2 t) {
    return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);
}

float noise4D(vec2 p) {
    vec4 Pi = floor(p.xyxy) + vec4(0.0, 0.0, 0.0, 1.0);
    vec4 Pf = fract(p.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);

    Pi = mod289(Pi);

    vec4 ix = Pi.xzxz;
    vec4 iy = Pi.yyww;
    vec4 fx = Pf.xzxz;
    vec4 fy = Pf.yyww;

    vec4 i = permute(permute(ix) + iy);
    vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0;
    vec4 gy = abs(gx) - 0.5;
    vec4 tx = floor(gx + 0.5);
    gx = gx - tx;

    vec2 g00 = vec2(gx.x, gy.x);
    vec2 g10 = vec2(gx.y, gy.y);
    vec2 g01 = vec2(gx.z, gy.z);
    vec2 g11 = vec2(gx.w, gy.w);
    vec4 norm = taylorInvSqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));
    g00 *= norm.x;
    g01 *= norm.y;
    g10 *= norm.z;
    g11 *= norm.z;

    float n00 = dot(g00, vec2(fx.x, fy.y));
    float n10 = dot(g10, vec2(fx.y, fy.y));
    float n01 = dot(g01, vec2(fx.z, fy.z));
    float n11 = dot(g11, vec2(fx.w, fy.w));

    vec2 fade_xy = fade(Pf.xy);
    vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);
    float n_xy = mix(n_x.x, n_x.y, fade_xy.y);
    return 2.3 * n_xy;
}

float noise(vec2 st) {
    vec2 i = floor(st);
    vec2 f = fract(st);

    float a = rand(i);
    float b = rand(i + vec2(1.0f, 0.0f));
    float c = rand(i + vec2(0.0f, 1.0f));
    float d = rand(i + vec2(1.0f, 1.0f));

    vec2 u = f * f * (3.0f - 2.0f * f);
    return mix(a, b, u.x) + (c - a) * u.y * (1.0f - u.x) + (d - b) * u.x * u.y;
}

float snoise(vec2 v)  {
    vec2 i = floor(v + dot(v, vec2(0.898, 0.2357)));
    vec2 x = v - i + dot(i, vec2(0.3678, 0.153));

    vec2 p;
    p = vec2(0.5) + 0.5*vec2(dot(x, x), dot(x, x + vec2(0.153, 0.9135)));

    vec2 lo = floor(x);
    vec2 hi = lo + vec2(1.0);
    vec2 f = smoothstep(vec2(0.0), vec2(1.0), fract(p));

    float n = (mix(dot(lo, vec2(0.153, 0.9135)), dot(hi, vec2(0.153, 0.9135)), f.x));
    n += (mix(dot(lo, vec2(0.898, 0.2357)), dot(hi, vec2(0.898, 0.2357)), f.y));
    return n;
}

float fbmNearest(vec3 x, int index) {
    float v = 0.0f;
    float a = uChunkMetadata[index].uSeedf.y;
    vec3 shift = vec3(100);
    for (int it = 0; it < uChunkMetadata[index].uSeedi; ++it) {
        v += a * noise(x.xy);
        x = x * (2.0f + uChunkMetadata[index].uSeedf.w) + shift;
        a *= uChunkMetadata[index].uSeedf.z;
    }
    return v;
}

float fbm(vec3 i) {
    float v = 0.0f;
    float a = uAmplitude;
    vec3 shift = vec3(100.0f);
    float lacunarity = 2.0f + uLacunarity;

    for (int it = 0; it < uOctaves; ++it) {
        v += a * noise(i.xy);
        i = i * (lacunarity) + shift;
        a *= uPersistence;
    }

    return v;
}

void main() {
    ivec2 pixelCoord = ivec2(gl_GlobalInvocationID.xy);
    vec2 size = imageSize(uTextureHeightmap);
    vec2 uv = (pixelCoord / size);
    vec2 newTexelCoord = pixelCoord;

    if (pixelCoord.x == size.x - 1) {
        newTexelCoord.x += 1;
    }

    if (pixelCoord.y == size.y - 1) {
        newTexelCoord.y += 1;
    }

    vec2 uvUnscaled = uv;
    vec2 uvNoised = uGlobalUV;

    uv += uGlobalUV;
    uvNoised += (newTexelCoord / size);
    float yLevel = fbm(vec3(uvNoised * uFrequency, PI));
    size -= 1; // Indexing start at 0 not 1.

    if (uCheckNearest) {
        vec2 uvNearest = uv;
        float predict = 0.0f;
        bool interpolate = false;

        for (int it = 0; it < 4; it++) {
            if (uChunkMetadata[it].uGlobalUV.z != -1) {
                uvNearest = uChunkMetadata[it].uGlobalUV.xy;
                predict = fbmNearest(vec3(uvNoised * uChunkMetadata[it].uSeedf.x, PI), it);
                interpolate = true;

                if (uvNearest.x < uGlobalUV.x && uvNearest.y == uGlobalUV.y && pixelCoord.x == 0) {
                    yLevel = predict;
                    interpolate = false;
                }

                if (uvNearest.x > uGlobalUV.x && uvNearest.y == uGlobalUV.y && pixelCoord.x == size.x) {
                    yLevel = predict;
                    interpolate = false;
                }

                if (uvNearest.x == uGlobalUV.x && uvNearest.y < uGlobalUV.y && pixelCoord.y == 0) {
                    yLevel = predict;
                    interpolate = false;
                }

                if (uvNearest.x == uGlobalUV.x && uvNearest.y > uGlobalUV.y && pixelCoord.y == size.y) {
                    yLevel = predict;
                    interpolate = false;
                }

                if (interpolate && (pixelCoord.x != 0 && pixelCoord.y != 0 && pixelCoord.x != size.x && pixelCoord.y != size.y)) {
                    yLevel = predict;
                }
            }
        }
    }

    ivec2 indexInfo = imageSize(uVegetationMap) - 1;

    if (pixelCoord.x == 0 && pixelCoord.y == 0) {
        imageStore(uVegetationMap, indexInfo, vec4(0, 0, 0, 0));
    }

    /* Store the size of vegetation at end of texture. */
    float vegetationFactor = noise4D(uGlobalUV * PI);
    float vegetationRadius = 512.0f;

    vec4 prevVegetation = imageLoad(uVegetationMap, indexInfo);
    vec3 prevVegPos = imageLoad(uVegetationMap, ivec2(prevVegetation.yz)).yzw * uChunkScale;
    vec3 currVegPos = vec3(uv.x, yLevel, uv.y) * uChunkScale;
    float currVegDist = length(currVegPos - prevVegPos);

    if (currVegDist > vegetationRadius && vegetationFactor > 0.444333333f && false) {
        imageStore(uVegetationMap, ivec2(prevVegetation.x, 0), vec4(1.0f, uv.x, yLevel, uv.y));
        imageStore(uVegetationMap, indexInfo, vec4(prevVegetation.x + 1.0f, pixelCoord.x, pixelCoord.y, 0.0f));
    }

    yLevel = clamp(yLevel, 0.0f, 1.0f);
    imageStore(uTextureHeightmap, pixelCoord, vec4(yLevel, 0.0f, 0.0f, 0.0f));
}